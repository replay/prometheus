// Copyright 2025 The Prometheus Authors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package dynamic_labels

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"sync"
	"time"

	"github.com/cespare/xxhash/v2"
	"github.com/fsnotify/fsnotify"
	"github.com/prometheus/prometheus/config"
	"github.com/prometheus/prometheus/model/labels"
	"gopkg.in/yaml.v2"
)

// LabelValueConfig defines how a dynamic label value is determined.
type LabelValueConfig struct {
	// StaticValue is a static string value for the label.
	StaticValue string
	// FromLabels is a list of source labels to check. The first existing label's value is used.
	FromLabels []string
	// JoinedLabels is a list of source labels to join.
	JoinedLabels []string
	// Separator is the string used to join values.
	Separator string
	// IsDynamic indicates whether this is a dynamic value (true) or static value (false).
	IsDynamic bool
}

// Rule represents a single dynamic label rule.
type Rule struct {
	// Matchers is a list of matcher sets. If any matcher set matches, the rule applies (OR logic).
	// Each matcher set is a list of matchers that must all match (AND logic within a set).
	Matchers [][]*labels.Matcher
	// Labels defines which labels should be assigned to matching series.
	// Each label has a value configuration (static or dynamic).
	Labels map[string]LabelValueConfig
}

// RuleProvider provides access to dynamic label rules.
type RuleProvider interface {
	// GetRules returns all dynamic label rules.
	GetRules() []Rule

	// GetDynamicLabelsForSeries returns the dynamic labels that should be added to the series
	// based on its intrinsic labels.
	GetDynamicLabelsForSeries(seriesLabels labels.Labels) labels.Labels

	// GetDynamicLabelNames returns all unique label names that are generated by dynamic rules.
	GetDynamicLabelNames() []string
}

// FileRuleProvider implements RuleProvider using a YAML file.
type FileRuleProvider struct {
	mu       sync.RWMutex
	rules    []Rule
	filename string
	watcher  *fsnotify.Watcher
	ctx      context.Context
	cancel   context.CancelFunc
	wg       sync.WaitGroup

	// cache stores computed labels per rule and per series.
	// Structure: ruleHash -> *sync.Map (seriesHash -> labels.Labels)
	cache      sync.Map
	ruleHashes []uint64
}

// NewFileRuleProvider creates a new FileRuleProvider and starts watching the file for changes.
func NewFileRuleProvider(filename string) (*FileRuleProvider, error) {
	ctx, cancel := context.WithCancel(context.Background())
	p := &FileRuleProvider{
		rules:    []Rule{},
		filename: filename,
		ctx:      ctx,
		cancel:   cancel,
	}

	if filename == "" {
		return p, nil
	}

	if err := p.Load(filename); err != nil {
		cancel()
		return nil, err
	}

	// Start watching the file for changes
	if err := p.startWatching(); err != nil {
		cancel()
		return nil, fmt.Errorf("start watching file: %w", err)
	}

	return p, nil
}

// Load loads rules from the given file.
// If filename is different from the currently watched file, the watcher is not updated.
// Use Reload() or create a new FileRuleProvider to change the watched file.
func (p *FileRuleProvider) Load(filename string) error {
	content, err := os.ReadFile(filename)
	if err != nil {
		return fmt.Errorf("read dynamic labels file: %w", err)
	}

	var cfg config.DynamicLabelsConfig
	if err := yaml.UnmarshalStrict(content, &cfg); err != nil {
		return fmt.Errorf("parse dynamic labels file: %w", err)
	}

	rules := make([]Rule, 0, len(cfg.DynamicLabels))
	for i, ruleConfig := range cfg.DynamicLabels {
		if len(ruleConfig.Labels) == 0 {
			return fmt.Errorf("rule at index %d has no labels", i)
		}

		// Parse each matcher string into a set of matchers
		matcherSets := make([][]*labels.Matcher, 0, len(ruleConfig.Matchers))
		for j, matcherStr := range ruleConfig.Matchers {
			matchers, err := ParseMatcherString(matcherStr)
			if err != nil {
				return fmt.Errorf("parse matcher at index %d in rule %d (%q): %w", j, i, matcherStr, err)
			}
			matcherSets = append(matcherSets, matchers)
		}

		// Convert label configurations
		labelConfigs := make(map[string]LabelValueConfig)
		for labelName, labelConfig := range ruleConfig.Labels {
			setCount := 0
			if labelConfig.SetValueStatic != nil {
				setCount++
			}
			if labelConfig.SetValueFromPrioritizedLabels != nil {
				setCount++
			}
			if labelConfig.SetValueFromJoinedLabels != nil {
				setCount++
			}

			if setCount != 1 {
				return fmt.Errorf("rule at index %d, label %q: must specify exactly one of set_value_static, set_value_from_prioritized_labels, or set_value_from_joined_labels", i, labelName)
			}

			if labelConfig.SetValueStatic != nil {
				labelConfigs[labelName] = LabelValueConfig{
					StaticValue: *labelConfig.SetValueStatic,
					IsDynamic:   false,
				}
			} else if labelConfig.SetValueFromPrioritizedLabels != nil {
				labelConfigs[labelName] = LabelValueConfig{
					FromLabels: labelConfig.SetValueFromPrioritizedLabels,
					IsDynamic:  true,
				}
			} else {
				labelConfigs[labelName] = LabelValueConfig{
					JoinedLabels: labelConfig.SetValueFromJoinedLabels.Labels,
					Separator:    labelConfig.SetValueFromJoinedLabels.Separator,
					IsDynamic:    true,
				}
			}
		}

		rules = append(rules, Rule{
			Matchers: matcherSets,
			Labels:   labelConfigs,
		})
	}

	// Compute hashes for new rules
	newRuleHashes := make([]uint64, len(rules))
	for i, rule := range rules {
		newRuleHashes[i] = computeRuleHash(rule)
	}

	p.mu.Lock()
	defer p.mu.Unlock()

	// Invalidate cache for rules that are no longer present
	newHashesMap := make(map[uint64]struct{}, len(newRuleHashes))
	for _, h := range newRuleHashes {
		newHashesMap[h] = struct{}{}
	}

	for _, oldHash := range p.ruleHashes {
		if _, exists := newHashesMap[oldHash]; !exists {
			p.cache.Delete(oldHash)
		}
	}

	p.rules = rules
	p.ruleHashes = newRuleHashes
	return nil
}

func (p *FileRuleProvider) GetRules() []Rule {
	p.mu.RLock()
	defer p.mu.RUnlock()
	// Return a copy to prevent external modification
	rules := make([]Rule, len(p.rules))
	copy(rules, p.rules)
	return rules
}

func (p *FileRuleProvider) GetDynamicLabelNames() []string {
	p.mu.RLock()
	defer p.mu.RUnlock()

	uniqueNames := make(map[string]struct{})
	for _, rule := range p.rules {
		for name := range rule.Labels {
			uniqueNames[name] = struct{}{}
		}
	}

	names := make([]string, 0, len(uniqueNames))
	for name := range uniqueNames {
		names = append(names, name)
	}
	sort.Strings(names)
	return names
}

func (p *FileRuleProvider) GetDynamicLabelsForSeries(seriesLabels labels.Labels) labels.Labels {
	p.mu.RLock()
	defer p.mu.RUnlock()

	var builder labels.ScratchBuilder
	seriesHash := seriesLabels.Hash()

	// Iterate through each rule
	for i, rule := range p.rules {
		// Safety check, though ruleHashes should always be populated in Load
		if i >= len(p.ruleHashes) {
			continue
		}
		ruleHash := p.ruleHashes[i]
		ruleCache := p.getOrCreateRuleCache(ruleHash)

		if cached, ok := ruleCache.Load(seriesHash); ok {
			if cachedLabels, ok := cached.(labels.Labels); ok {
				cachedLabels.Range(func(l labels.Label) {
					builder.Add(l.Name, l.Value)
				})
				continue
			}
		}

		// Check if any matcher set matches (OR logic)
		ruleMatches := false
		for _, matcherSet := range rule.Matchers {
			// All matchers in a set must match (AND logic)
			setMatches := true
			for _, m := range matcherSet {
				val := seriesLabels.Get(m.Name)
				if !m.Matches(val) {
					setMatches = false
					break
				}
			}
			if setMatches {
				ruleMatches = true
				break
			}
		}

		var ruleLabels labels.Labels
		// If the rule matches, add all its labels
		if ruleMatches {
			var ruleBuilder labels.ScratchBuilder
			for name, valueConfig := range rule.Labels {
				var value string
				if valueConfig.IsDynamic {
					if len(valueConfig.JoinedLabels) > 0 {
						// Handle joined labels
						var joinedValue string
						allFound := true
						for i, sourceLabel := range valueConfig.JoinedLabels {
							val := seriesLabels.Get(sourceLabel)
							if val == "" {
								allFound = false
								break
							}
							if i > 0 {
								joinedValue += valueConfig.Separator
							}
							joinedValue += val
						}
						if allFound {
							value = joinedValue
						}
					} else {
						// Iterate through source labels and pick the first one that exists
						for _, sourceLabel := range valueConfig.FromLabels {
							if val := seriesLabels.Get(sourceLabel); val != "" {
								value = val
								break
							}
						}
					}
				} else {
					value = valueConfig.StaticValue
				}
				if value != "" {
					ruleBuilder.Add(name, value)
					builder.Add(name, value)
				}
			}
			ruleBuilder.Sort()
			ruleLabels = ruleBuilder.Labels()
		} else {
			ruleLabels = labels.EmptyLabels()
		}

		ruleCache.Store(seriesHash, ruleLabels)
	}

	builder.Sort()
	return builder.Labels()
}

func (p *FileRuleProvider) getOrCreateRuleCache(ruleHash uint64) *sync.Map {
	if v, ok := p.cache.Load(ruleHash); ok {
		return v.(*sync.Map)
	}
	v, _ := p.cache.LoadOrStore(ruleHash, &sync.Map{})
	return v.(*sync.Map)
}

func computeRuleHash(rule Rule) uint64 {
	h := xxhash.New()

	// Hash matchers
	for _, matcherSet := range rule.Matchers {
		for _, m := range matcherSet {
			h.WriteString(m.Type.String())
			h.WriteString(m.Name)
			h.WriteString(m.Value)
		}
	}

	// Hash label configs
	// To ensure deterministic hashing, we need to iterate keys in order
	labelNames := make([]string, 0, len(rule.Labels))
	for name := range rule.Labels {
		labelNames = append(labelNames, name)
	}
	sort.Strings(labelNames)

	for _, name := range labelNames {
		h.WriteString(name)
		config := rule.Labels[name]
		if config.IsDynamic {
			h.WriteString("dynamic")
			if len(config.JoinedLabels) > 0 {
				h.WriteString("joined")
				for _, l := range config.JoinedLabels {
					h.WriteString(l)
				}
				h.WriteString("sep")
				h.WriteString(config.Separator)
			} else {
				for _, l := range config.FromLabels {
					h.WriteString(l)
				}
			}
		} else {
			h.WriteString("static")
			h.WriteString(config.StaticValue)
		}
	}

	return h.Sum64()
}

// startWatching starts a goroutine that watches the file for changes and reloads rules automatically.
func (p *FileRuleProvider) startWatching() error {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		return fmt.Errorf("create file watcher: %w", err)
	}
	p.watcher = watcher

	// Try to watch the file directly first
	if err := watcher.Add(p.filename); err != nil {
		// If watching the file fails, watch the directory instead
		// This handles cases where the file doesn't exist yet or the system doesn't support file watching
		dir := filepath.Dir(p.filename)
		if dir == "" {
			dir = "."
		}
		if err := watcher.Add(dir); err != nil {
			watcher.Close()
			return fmt.Errorf("add watch for file %q or directory %q: %w", p.filename, dir, err)
		}
	} else {
		// Also watch the directory to catch rename operations (common with editors)
		dir := filepath.Dir(p.filename)
		if dir != "" && dir != "." {
			// Ignore error if directory watch fails, file watch should still work
			_ = watcher.Add(dir)
		}
	}

	p.wg.Add(1)
	go p.watchLoop()

	return nil
}

// watchLoop runs in a goroutine and watches for file changes.
func (p *FileRuleProvider) watchLoop() {
	defer p.wg.Done()

	// Debounce rapid file changes
	var reloadTimer *time.Timer
	var reloadTimerMu sync.Mutex

	reload := func() {
		reloadTimerMu.Lock()
		defer reloadTimerMu.Unlock()

		if reloadTimer != nil {
			reloadTimer.Stop()
		}

		// Debounce: wait 100ms after the last change before reloading
		reloadTimer = time.AfterFunc(100*time.Millisecond, func() {
			if err := p.Load(p.filename); err != nil {
				// Log error but don't stop watching
				// In a real implementation, we might want to use a logger here
				// For now, we'll silently continue watching
				_ = err
			}
		})
	}

	for {
		select {
		case <-p.ctx.Done():
			reloadTimerMu.Lock()
			if reloadTimer != nil {
				reloadTimer.Stop()
			}
			reloadTimerMu.Unlock()
			return

		case event, ok := <-p.watcher.Events:
			if !ok {
				return
			}

			// fsnotify sometimes sends events without name or operation - filter them out
			if len(event.Name) == 0 {
				continue
			}

			// Only reload on write/rename/create events, not on chmod
			if event.Op&fsnotify.Chmod == event.Op {
				continue
			}

			// Check if the event is for our file
			// We watch the directory, so we need to check if the event is specifically for our file
			eventPath, err := filepath.Abs(event.Name)
			if err != nil {
				continue
			}
			targetPath, err := filepath.Abs(p.filename)
			if err != nil {
				continue
			}

			// For rename events (common when editors save), check if the target is our file
			if event.Op&fsnotify.Rename != 0 {
				// After a rename, the file might have been moved to our target
				// Give it a moment and check if our file exists and was modified
				time.Sleep(50 * time.Millisecond)
				if _, err := os.Stat(p.filename); err == nil {
					// Check if this rename event might be related to our file
					// (e.g., editor writes to temp file then renames to our file)
					reload()
				}
			} else if eventPath == targetPath {
				// For write/create events, reload if it's our file
				reload()
			}

		case err, ok := <-p.watcher.Errors:
			if !ok {
				return
			}
			// Log error but continue watching
			// In a real implementation, we might want to use a logger here
			_ = err
		}
	}
}

// Stop stops watching the file and cleans up resources.
func (p *FileRuleProvider) Stop() {
	p.cancel()
	if p.watcher != nil {
		p.watcher.Close()
	}
	p.wg.Wait()
}
